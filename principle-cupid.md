**What is CUPID?**
CUPID is an acronym for five properties or characteristics of software that are believed to make it a joy to work with. The more your code possesses these qualities, the more joyful it is, though the author notes that everything involves trade-offs, and context is important. CUPID was developed as a response to the SOLID principles, which the author found less useful.

The five CUPID properties are listed as:

- **C**omposable: plays well with others.
- **U**nix philosophy: does one thing well.
- **P**redictable: does what you expect.
- **I**diomatic: feels natural.
- **D**omain-based: the solution domain models the problem domain in language and structure.

**Properties vs. Principles**
A key aspect of CUPID is that it defines _properties_ rather than _principles_. The author views principles, like the SOLID principles, as rules where code is either compliant or not. This can create "bounded sets" of rule-followers and enforcers. In contrast, properties are qualities or characteristics that define a goal or "centre". Code can be assessed based on how close or far it is from this centre, providing a clear direction for improvement. Adopting properties means there is no "all-in" or "failure," only continuous improvement.

The author suggests that useful properties should be practical, human, and layered.

- **Practical:** They should be easy to articulate (describe with examples), easy to assess (use as a lens to review code and decide how much it exhibits the property), and easy to adopt (start small and evolve incrementally).
- **Human:** They should be described from the perspective of people working with the code, focusing on what it _feels_ like, rather than an abstract description of the code itself. For example, the Unix philosophy is about how you _use_ code, while the Single Responsibility Principle (SRP) is about code's internal organisation.
- **Layered:** They should offer guidance for beginners while also providing nuance for experienced developers. Each property is intended to be understandable from its name and brief description but embodies many layers and approaches.

**The Five CUPID Properties Explained**

1.  **Composable:** Code that is easy to use tends to be reused. Characteristics of composable code, though not strict guarantees, include having a small surface area (narrow API), being intention-revealing (easy to discover and assess if it's what's needed), and having minimal dependencies. Minimal dependencies reduce concerns and incompatibilities. Intention-revealing code can sometimes lead to serendipitous discovery of existing code with similar names.
2.  **Unix philosophy:** This property draws inspiration from the Unix operating system's enduring technical appeal, which is rooted in its simple and consistent design philosophy. The core idea is to write components that work together well and _do one thing and do it well_. This is seen as an _outside-in_ perspective, focusing on a specific, well-defined purpose, unlike the _inside-out_ perspective of SRP, which is about code organisation ("one, and only one, reason to change"). The author argues that SRP can sometimes create artificial divisions and administrative overhead, whereas Composability and Domain-based structure are better indicators for making structural changes as a codebase grows. Examples of this philosophy in Unix commands like `ls`, `cat`, and `grep` are provided.
3.  **Predictable:** Predictable code does what it appears to do, consistently and reliably, without surprises. It should be easy to confirm its behaviour. Predictability is considered a generalisation of testability. Predictable code should behave as expected, be deterministic, and observable.
    - "Behaves as expected" means the intended behaviour is obvious from structure and naming, even without automated tests, and if tests are needed, they should be easy to write.
    - "Deterministic" means the software does the same thing every time, within defined functional or operational bounds. This includes being robust (covering a breadth of situations), reliable (acting as expected in covered situations), and resilient (handling unexpected situations well).
    - "Observable" (in the control theory sense) means internal state can be inferred from outputs, which requires designing in instrumentation, telemetry, monitoring, and alerting from the outset.
4.  **Idiomatic:** Idiomatic code "feels natural" and reduces the cognitive load associated with working with unfamiliar code by conforming to established styles and conventions. It is described as writing code with empathy for the people who will work with it later, including future you. This involves being familiar with the language, its libraries, toolchain, and ecosystem. Some languages (like Go and Python) are opinionated and make it easier to write idiomatic code, sometimes having explicit guides or formatters. Other languages (like Scala, Ruby, JavaScript, and Perl) are multi-paradigm, offering multiple ways to achieve the same result, which can increase cognitive load if idioms aren't followed. Learning the idioms of the language, its ecosystem, and community is important for writing empathic, joyful code. Local idioms should be established when a language lacks consensus. Architecture Decision Records (ADRs) can be used to document decisions about style and idioms.
5.  **Domain-based:** This property emphasises writing software that conveys its purpose using the language and structure of the problem domain, minimising the cognitive distance between the problem and the solution.
    - "Domain-based language" means using domain terms for types and operations (e.g., `Surname` type instead of `string`, `Money` type instead of a floating point value), not just using the right words. This helps in articulating and navigating the solution space and can prevent subtle bugs. Domain-driven design (DDD) is a software design approach that focuses on modeling software to match a domain according to input from domain experts, where the structure and language of the code match the business domain. DDD aims to place focus on the core domain, base designs on a domain model, and foster collaboration between technical and domain experts. A key concept in DDD is the "ubiquitous language" shared by experts, users, and developers, used in the domain model and requirements. The Domain-based property aligns closely with these DDD principles, particularly the idea of code reading like the domain logic.
    - "Domain-based structure" means the layout of the code (directories, files, groupings) mirrors the problem domain, rather than being dictated by a framework's predefined structure (like the typical MVC structure in Rails). Framework-based structures, particularly interpretations of SRP that mandate separating components like views and controllers into different locations, can increase cognitive load and reduce cohesion. Structuring code based on domain use cases makes it easier to understand and navigate.
    - "Domain-based boundaries" allow module boundaries to align with domain boundaries, simplifying deployment and packaging. This alignment reduces complexity regardless of whether the architecture is a monolith or microservices.

**Relationship to other Concepts**
Beyond the direct contrast with SOLID, the sources connect CUPID, particularly the Domain-based property, to **Domain-Driven Design (DDD)**. The detailed Wikipedia source on DDD provides significant depth to the concepts underpinning the Domain-based property, discussing ubiquitous language, bounded contexts, aggregate roots, events, and context mapping patterns, all relevant to modelling complex domains. The Hexagonal Architecture source explicitly connects Hexagonal Architecture to DDD, stating that it places the business domain at the centre. This reinforces the importance of the Domain-based property and how architectural styles can support it. Hexagonal Architecture's focus on isolating business logic and simplifying testing also aligns with the goals of predictability and facilitating focus on the domain.

The Unix philosophy property is rooted in the design principles of the Unix OS, specifically the idea of components doing one thing well. This concept of focused purpose also echoes the **KISS principle** ("Keep It Simple, Stupid"), which advocates for simplicity to improve maintainability, debugging, scalability, performance, and reduce technical debt. While not directly linked in the CUPID source, the underlying philosophy of simplicity is complementary.

The Predictable property's connection to testability aligns with the benefits of Hexagonal Architecture, which simplifies business logic testing and promotes practices like Test-Driven Development (TDD) and Behavior-Driven Development (BDD).

Overall, the sources present CUPID not as a rigid set of rules, but as a set of aspirational qualities that can guide software development to create code that is more intuitive, reliable, understandable, and ultimately, a joy to work with. The properties are seen as mutually reinforcing. The author is keen for practitioners to adopt and share their experiences with CUPID.

sources: https://dannorth.net/cupid-for-joyful-coding/
